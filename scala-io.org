#+title: Category-parametric Programming
#+author: Greg Pfeil
#+description: Where and how categorical thinking may help and hinder your Scala.
#+options: d:(not speakernotes)
#+drawers: speakernotes
#+epresent_frame_level: 4
#+epresent_mode_line: (" @sellout ‚Äî greg@technomadic.org ‚Äî Category-parametric Programming                           " (:eval (int-to-string epresent-page-number)))
















* Who?

Greg Pfeil

Formation.ai ‚Äì ML for customer relationships

- Ross Baker (@rossabaker)
- Kris Nuttycombe (@nuttycom)
- Paul Snively (@paulÔºøsnively)
















:speakernotes:
Hiring Scala & Haskell devs (and many other roles) ‚Äì if you find anything in this talk intriguing, you should talk to me about applying. Don‚Äôt let this talk dissuade you at all, though ‚Äì understanding this is by no means a prerequisite for any position we have. (But my co-workers have certainly helped me work through some of these ideas).
:END:

** Recursion Schemes

[[file:~/Downloads/where_turtles2.jpg]]

:speakernotes:
So, you may know me from such projects as Matryoshka (there‚Äôs a talk tomorrow at noon). And I ported that to Cats, calling it Turtles. The most common question I get now is
:END:

** +Recursion Schemes+

- andyscott/droste ‚Äì Andy Scott (@andygscott)
- vil1/recursion-schemes-cookbook ‚Äì Valentin Kasas (@ValentinKasas)

:speakernotes:
Turtles is pretty much kaput. There is a new upstart ‚Äì Droste ‚Äì recursion schemes for Cats with dedicated and active maintainers. I‚Äôm one of them, but so far inactive. Andy Scott at Stripe is leading it.

I‚Äôm also working on a recursion scheme cookbook with one of the organizers(?) (member of the program committee?) here ‚Äì Valentin Kasas.

But this talk isn‚Äôt about recursion schemes. At least not directly. But in a different way, it is, because it‚Äôs about everything, because it‚Äôs about ‚Ä¶ Categories!
:END:

* Quote!

‚ÄúMost if not all constructions in category theory are parametric in the underlying category, resulting in a remarkable economy of expression. [‚Ä¶] This possibly leads to a new style of programming, which could be loosely dubbed as /category-parametric programming/.‚Äù
#+begin_justifyright
                                                 ‚îÄ‚îÄ‚îÄRalf Hinze, [[http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf][Adjoint Folds and Unfolds]]
#+end_justifyright

* familiarity calibration

:speakernotes:
I‚Äôm just checking which of these things you may be more-or-less familiar with. So, keep your hands up for any slides you understand at a glance, and put them down for slides you don‚Äôt understand. This helps me figure out which other slides I should maybe move through quickly or explain more carefully. If you do find yourself bewildered by the end ‚Äì that‚Äôs /my/ fault, not yours. I will happily sit down with anyone to work through any and all of it. (And you can also find me on the Internet if you think of something after the conference has ended ‚Äì my Twitter and email are on the bottom of every slide).

There is nothing about not knowing any of these that makes you a ‚Äúworse‚Äù programmer than someone who does know them ‚Äì different people are introduced to different ideas at different times. So, don‚Äôt feel like you /should/ be familiar with these ‚Äì just
:END: 

[[file:~/Downloads/calibration.jpg]]

















** the setup

:speakernotes:
#+begin_src sbt :tangle project/build.properties
sbt.version=1.2.3
#+end_src
:END:

#+begin_src sbt :tangle build.sbt
inThisBuild(Seq(
  scalaOrganization := "org.typelevel",
  scalaVersion := "2.12.4-bin-typelevel-4",
  scalacOptions := Seq(
    "-language:higherKinds",
    "-Ykind-polymorphism"),
  libraryDependencies := Seq(
    "org.typelevel" %% "cats-core"   % "1.3.1",
    "org.typelevel" %% "cats-effect" % "1.0.0")))

addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.8")
#+end_src

#+begin_src scala :tangle CategoryParametric.scala
import cats.implicits._

package object CategoryParametric {
#+end_src

#+begin_src scala :tangle Calibration.scala
package object Calibration {
#+end_src

:speakernotes:
This is a literate presentation, so here is everything necessary for the rest of the code in this presentation to compile. There is really just one section of the code that requires dotty (or a Typelevel-branded scalac) ‚Äì the rest should work fine with a current release of things.
:END:

** ~kind-projector~

#+begin_src scala
Either[String, ?]

cats.arrow.FunctionK[List, ?[_]]
#+end_src

** composition

#+begin_src scala
def f: Boolean => Char
def g: String => Boolean

f <<< g

(a: String) => f(g(a))
#+end_src

** higher-order functions

#+begin_src scala

  def map[A, B](fa: List[A])(f: A => B): List[B]



  def flatMap[A, B](fa: List[A])(f: A => List[B]): List[B]

#+end_src

** type classes

#+begin_src scala :tangle Calibration.scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

trait Monad[M[_]] extends cats.Applicative[M] {
  def flatMap[A, B](fa: M[A])(f: A => M[B]): M[B]
}
#+end_src

** monoids

#+begin_src scala :tangle Calibration.scala
trait Monoid[A] {
  def empty: A
  def combine(a: A, b: A): A
}
#+end_src

:speakernotes:
I use Cats terminology in this talk, when it comes to the names of traits and types, but it should hopefully be understandable regardless of the terminology you‚Äôre familiar with ‚Äì after all, names don‚Äôt matter ‚Ä¶ right?
:END:

** categories

#+begin_src scala :tangle Calibration.scala
trait Category[‚üπ[_, _]] {
  def id[A]: A ‚üπ A
  def compose[A, B, C](f: B ‚üπ C, g: A ‚üπ B): A ‚üπ C
}
#+end_src

#+begin_src scala :tangle Calibration.scala
}
#+end_src

* categories

#+begin_src scala :tangle CategoryParametric.scala
trait Category[‚üπ[_, _]] {
  def id[A]: A ‚üπ A
  def compose[A, B, C](f: B ‚üπ C, g: A ‚üπ B): A ‚üπ C
}
#+end_src

- objects
- morphisms between objects
- that can be composed
- there is an identity morphism for each object
















** *Scal*

:speakernotes:
*Scal* is the name we use for the category where the objects are Scala types and the morphisms are Scala functions.
:END:

#+begin_src scala :tangle CategoryParametric.scala
implicit val scal: Category[Function1] = new Category[Function1] {
  def id[A] = Predef.identity
  def compose[A, B, C](f: B => C, g: A => B) = f.compose(g)
}
#+end_src

** *Kleisli*

#+begin_src scala :tangle CategoryParametric.scala
// from cats.data
final case class Kleisli[F[_], A, B](run: A => F[B])
#+end_src

#+begin_src scala :tangle CategoryParametric.scala
implicit def kleisli[M[_]](implicit M: cats.Monad[M])
    : Category[Kleisli[M, ?, ?]] =
  new Category[Kleisli[M, ?, ?]] {
    def id[A] = Kleisli(M.pure[A])
    def compose[A, B, C](f: Kleisli[M, B, C], g: Kleisli[M, A, B]) =
      Kleisli(a => M.flatMap(g.run(a))(f.run))
}
#+end_src

* composition

:speakernotes:
So, looking at the definition of ~Category~, is there anything that‚Äôs missing?

Proper values!

The only values we have are the morphisms. And the only thing we can do to them is compose them.

Scala is not great at composition. It expects things to be applied, otherwise you have to provide it with lots of types to tell it what you want.
:END:

#+begin_src scala
trait Category[‚üπ[_, _]] {
  def id[A]: A ‚üπ A
  def compose[A, B, C](f: B ‚üπ C, g: A ‚üπ B): A ‚üπ C
}
#+end_src

# ** ‚Äúpoint-free‚Äù style

# Since category theory doesn‚Äôt operate at the levels of values, this talk will mostly deal with types, and ‚Ä¶ uh, things like types. However, as mentioned previously, we can really only do one thing when working with categories ‚Äì compose. This leads to a way of programming called point-free.

# It‚Äôs a contentious style. In Haskell, it‚Äôs at least common in simple cases. When we get to more complicated cases, it can often be non-obvious what‚Äôs happening. I think it‚Äôs reasonable for programmers to be on either side of the issue, but if you‚Äôre thinking and working categorically, then point-free is the only option.

* Why?

:speakernotes:
Why do we care about categories?

The same reason we might care about interfaces, or type classes ‚Äì /abstraction/!

Even if we can‚Äôt have a fully abstract implementation, understanding the common abstraction can help us see larger similarities between things.

Category theory is the ultimate abstraction. Everything from every field of mathematics (like, type theory) maps to category theory. Not only can you see how ideas in your particular area relate to each other more clearly, but you can also see how your ideas map to ideas in other branches of mathematics.
:END:

- Eugenia Cheng ‚Äì [[https://www.youtube.com/watch?v=cSRVywjDP8E][Category Theory and Life]]

* functors

:speakernotes:
#+begin_src latex :file functor.pdf :packages '(("" "tikz"))
\usetikzlibrary{cd}
\begin{tikzcd}
A \ar[r, "f"] \ar[d, "F"] & B \ar[d, "F"] \\
A_F \ar[r, "f_F"] & B_F
\end{tikzcd}
#+end_src
:END:

#+RESULTS:
[[file:functor.pdf]]

:speakernotes:
#+begin_src latex :file functor_map.pdf :packages '(("" "tikz"))
\usetikzlibrary{cd}
\begin{tikzcd}
A \ar[r, "f"] \ar[d, "F"] & B \ar[d, "F"] \\
A_F \ar[r, "map(f)"] & B_F
\end{tikzcd}
#+end_src
:END:

#+RESULTS:
[[file:functor_map.pdf]]
















** aligning ~Functor~

#+begin_src scala :tangle CategoryParametric.scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

trait Functor π[F[_]] {
  def map[A, B](f: A => B)(fa: F[A]): F[B]
}

trait Functor π π[F[_]] {
  def map[A, B](f: A => B): F[A] => F[B]
}
#+end_src

** generalizing endofunctors

#+begin_src scala :tangle CategoryParametric.scala
trait Endofunctor π[‚üπ[_, _], F[_]] {
  def map[A, B](f: A ‚üπ B): F[A] ‚üπ F[B]
}
#+end_src

** ‚Ä¶ to functors

#+begin_src scala :tangle CategoryParametric.scala
trait Exofunctor[‚üπ[_, _], ‚üæ[_, _], F[_]] {
  def map[A, B](f: A ‚üπ B): F[A] ‚üæ F[B]
}
#+end_src

** endofunctors

#+begin_src scala :tangle CategoryParametric.scala
type Endofunctor[‚üπ[_, _], F[_]] = Exofunctor[‚üπ, ‚üπ, F]

type Functor π π π[F[_]] = Endofunctor[Function1, F]
// `map[A, B](f: A => B): F[A] => F[B]` is `map`
#+end_src
















*** ~Traverse~

#+begin_src scala :tangle CategoryParametric.scala
type Traverse[M[_], F[_]] = Endofunctor[Kleisli[M, ?, ?], F]
// `map[A, B](f: A => M[B]): F[A] => M[F[B]]` is `traverse`

implicit def optionTraverse[M[_]: Applicative] =
  new Traverse[M, Option] {
    def map[A, B](f: Kleisli[M, A, B]) = null
  }

implicit def idTraverse[M[_]] = new Traverse[M, cats.Id] {
  def map[A, B](f: Kleisli[M, A, B]) = null
}

implicit val ioTraverse = new Traverse[cats.Id, cats.effect.IO] {
  def map[A, B](f: Kleisli[cats.Id, A, B]) = null
}
#+end_src

*** unify ~Functor~ and ~Traverse~?

#+begin_src scala :tangle CategoryParametric.scala
type Functor π π π π[F[_]] = Traverse[cats.Id, F]
// `map[A, B](f: A => Id[B]): F[A] => Id[F[B]]` is `map`
#+end_src

** exofunctors

#+begin_src scala :tangle CategoryParametric.scala
type KleisliFunctor[M[_], F[_]] =
  Exofunctor[cats.data.Kleisli[M, ?, ?], Function1, F]

type FunctorFilter[F[_]] = KleisliFunctor[Option, F]
// `map[A, B](f: A => Option[B]): F[A] => F[B]` is `mapFilter`
type FlatMap[F[_]] = KleisliFunctor[F, F]
// `map[A, B](f: A => F[B]): F[A] => F[B]` is `flatMap`
#+end_src

#+begin_src scala :tangle CategoryParametric.scala
type CokleisliFunctor[M[_], F[_]] =
  Exofunctor[cats.data.Cokleisli[M, ?, ?], Function1, F]

type CoflatMap[F[_]] = CokleisliFunctor[F, F]
// `map[A, B](f: F[A] => B): F[A] => F[B]` is `coflatMap`
#+end_src

** duality


#+begin_src scala :tangle CategoryParametric.scala
// from cats.data
final case class Op[‚üπ[_, _], A, B](run: B ‚üπ A)
#+end_src

#+begin_src scala :tangle CategoryParametric.scala
type Presheaf[‚üπ[_, _], F[_]] = Exofunctor[Op[‚üπ, ?, ?], ‚üπ, F]

type Contravariant[F[_]] = Presheaf[Function1, F]
// `map[A, B](f: B => A): F[A] => F[B]` is `contramap`
#+end_src
















*** What category are we in?!

#+begin_src scala
// from cats.data
final case class Op[‚üπ[_, _], A, B](run: B ‚üπ A)
#+end_src

#+begin_src scala
Op[Kleisli[F, ?, ?], A, B] // (A => F[B]) => (B => F[A])
Op[Function1, A, F[B]]     // (A => F[B]) => (F[B] => A)
#+end_src

:speakernotes:
Duality can be confusing if you don‚Äôt know what category you‚Äôre working in.
For example, what is the dual of ~A ‚áí M[B]~?
If you‚Äôre in *Scal*, the category of Scala types, the dual would be ~M[B] ‚áí A~.
But if you‚Äôre in a Kleisli category, then the dual would be ~B ‚áí M[A]~.

I.e., in a Kleisli category, the ~M~ is part of the morphism, in *Scal* it‚Äôs part of the object.
:END:

** subcategories

:speakernotes:
But ‚Ä¶ we can‚Äôt abstract over the constraint, so we‚Äùd have to explicitly create a new morphism type for each set of constraints.
:END:

#+begin_src scala :tangle CategoryParametric.scala
final case class OrdFunction1
  [A: cats.kernel.Order, B: cats.kernel.Order]
  (run: A => B)

val setFunctor = new Exofunctor[OrdFunction1, Function1, Set] {
  def map[A, B](f: OrdFunction1[A, B]) = _.map(f.run)
}

val boolSet: Set[Boolean] =
  setFunctor.map(
    OrdFunction1[Int, Boolean](_ % 2 == 0))(
    Set(0, 1, 2, 3))
#+end_src














*** other /kinds/ of functors

#+begin_src scala :tangle CategoryParametric.scala
trait Exofunctor π[‚üπ[_   , _   ], ‚üæ[_   , _   ], F[_      ]] {
  def map[A   , B   ](f: A ‚üπ B): F[A   ] ‚üæ F[B   ]
}
#+end_src
















*** functors in a functor category

#+begin_src scala :tangle CategoryParametric.scala
trait ExofunctorK[‚üπ[_[_], _[_]], ‚üæ[_[_], _[_]], F[_[_], _]] {
  def map[A[_], B[_]](f: A ‚üπ B): F[A, ?] ‚üæ F[B, ?]
}

type Hoist[F[_[_], _]] =
  ExofunctorK[cats.arrow.FunctionK, cats.arrow.FunctionK, F]
#+end_src
















*** bifunctors

#+begin_src scala :tangle CategoryParametric.scala
trait Bifunctor[‚ü∂[_, _], ‚üπ[_, _], ‚üæ[_, _], F[_, _]] {
  def map[A, B, C, D](f: A ‚ü∂ C, g: B ‚üπ D): F[A, B] ‚üæ F[C, D]
}
type Bifunctor π[F[_, _]] =
  Bifunctor[Function1, Function1, Function1, F]
// `map[A, B, C, D](f: A => C, g: B => D): F[A, B] => F[C, D]`
//  is `bimap`
#+end_src

*** profunctors

#+begin_src scala :tangle CategoryParametric.scala
type Profunctor[‚ü∂[_, _], ‚üπ[_, _], F[_, _]] =
  Bifunctor[cats.data.Op[‚üπ, ?, ?], ‚ü∂, Function1, F]

type Profunctor π[F[_, _]] = Profunctor[Function1, Function1, F]
// `map[A, B, C, D](f: C => A, g: B => D): F[A, B] => F[C, D]`
//  is `dimap`

type HomFunctor[‚üπ[_, _], F[_,_]] =
  Bifunctor[cats.data.Op[‚üπ, ?, ?], ‚üπ, ‚üπ, F]

type Profunctor π π[F[_, _]] = HomFunctor[Function1, F]
#+end_src

** What are the problems with this?

- breaks inference
- often wrapping and unwrapping
- can make type class inheritance difficult
- gives us (or at least /me/) a taste of something I want more of

* Monoids

#+begin_src scala :tangle CategoryParametric.scala
trait Monoid[A] {
  def empty: A
  def combine(x: A, y: A): A
}

case class MonoidLaws[A](monoid: Monoid[A]) {
  def associative(x: A, y: A, z: A) =
    monoid.combine(monoid.combine(x, y), z) ==
      monoid.combine(x, monoid.combine(y, z))
  def leftIdentity(x : A) = monoid.combine(monoid.empty, x) == x
  def rightIdentity(x : A) = monoid.combine(x, monoid.empty) == x
}
#+end_src
















** abstract over the category ‚Ä¶

:speakernotes:
~identity~ isn‚Äôt a morphism, though. And is ~op~? How can we fix these?
:END:

#+begin_src scala
trait Monoid π π[‚üπ[_, _], A] {
  def identity: Unit ‚üπ A
  def op: (A, A) ‚üπ A
}
#+end_src

** but it‚Äôs a /monoidal/ category

:speakernotes:
A monoid in a ‚Äúmonoidal category‚Äù is an object with two particular morphisms ‚Ä¶
:END:

#+begin_src scala :tangle CategoryParametric.scala
trait CMonoid[‚üπ[_, _], I, ‚äó[_, _], A] {
  def identity: I ‚üπ A
  def op: (A ‚äó A) ‚üπ A
}

type Monoid π[A] = CMonoid[Function1, Unit, Tuple2, A]
#+end_src
















*** fixing a problem

:speakernotes:
but this new ~Monoid π~ looks a bit different than Cats‚Äô version, right? We have to apply ~identity~ to ~()~, and we have to apply ~ap~ to a single ~Tuple2~, rather than to a pair of arguments. We can always add another wrapper:
:END:

#+begin_src scala :tangle CategoryParametric.scala
trait ProperMonoid π[A] extends CMonoid[Function1, Unit, Tuple2, A] {
  def empty: A
  def combine(a: A, b: A): A

  final def identity = (_: Unit) => empty
  final def op = (tup: (A, A)) => combine(tup._1, tup._2)
}
#+end_src

:speakernotes:
And now we can define and use the ~Monoid~ we usually want, without losing the generality of ~CMonoid~.
:END:

*** ~?~ ‚áí ~?[_]~

:speakernotes:
Now we‚Äôre going to talk about a different /kind/ of monoid ‚Ä¶
:END:

#+begin_src scala :tangle CategoryParametric.scala
trait CMonoid π[‚üπ[_   , _   ], I   , ‚äó[_   , _      ], A   ] {
  def identity: I ‚üπ A
  def op: (A ‚äó A) ‚üπ A
}
#+end_src

*** ~MonoidK~

#+begin_src scala :tangle CategoryParametric.scala
trait CMonoidK[‚üπ[_[_], _[_]], I[_], ‚äó[_[_], _[_], _], A[_]] {
  def identity: I ‚üπ A
  def op: ‚äó[A, A, ?] ‚üπ A
}
#+end_src

*** a monad is ‚Äújust‚Äù ‚Ä¶

#+begin_src scala :tangle CategoryParametric.scala
trait Monad[M[_]]
    extends CMonoidK[cats.arrow.FunctionK,
                     cats.Id,
                     cats.data.Nested,
                     M] {
  def pure[A](a: A): M[A]
  def join[A](fa: M[M[A]]): M[A]

  final def identity = Œª[cats.arrow.FunctionK[cats.Id, M]](pure(_))
  final def op =
    Œª[cats.arrow.FunctionK[cats.data.Nested[M, M, ?], M]](
      a => join(a.value))
}
#+end_src

:speakernotes:
Note that these instances are defined in terms of ~map2~ and ~join~, rather than ~ap~ and ~flatMap~. That‚Äôs a trivial issue to get around, though.

What‚Äôs more complicated is that we /know/ that every ~Monad~ implies an ~Applicative~, and we usually show that by having ~Monad[M[_]] extends Applicative[M]~, but we have a problem here ‚Äì ~identity~ matches up, but that would give us two /distinct/ implementations of ~op~!
:END:

*** and so is ~Applicative~

#+begin_src scala :tangle CategoryParametric.scala
final abstract class Day[F[_], G[_], C] {
  type A
  type B
  def fa: F[A]
  def gb: G[B]
  def f(a: A, b: B): C
}

trait Applicative[F[_]]
     extends CMonoidK[cats.arrow.FunctionK, cats.Id, Day, F] {
  def pure[A](a: A): F[A]
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]

  final def identity = Œª[cats.arrow.FunctionK[cats.Id, F]](pure(_))
  final def op = Œª[cats.arrow.FunctionK[Day[F, F, ?], F]](
    day => map2(day.fa, day.gb)(day.f))
}
#+end_src

** a trick


















:speakernotes:
I pulled a bit of a trick at the beginnig of this talk, and I wonder if anyone noticed. I‚Äôm going to do it again a bit more slowly, and raise your hand if you think you know what the trick is. I haven‚Äôt given away the answer yet, but I‚Äôve shown a number of steps that lead to it.
:END:

*** Monoids

#+begin_src scala :tangle CategoryParametric.scala
trait Monoid π π π[A] {
  def empty: A
  def combine(a: A, b: A): A
}
#+end_src

*** Categories

#+begin_src scala :tangle CategoryParametric.scala
trait Category π[‚üπ[_, _]] {
  def id[A]: A ‚üπ A
  def compose[A, B, C](f: B ‚üπ C, g: A ‚üπ B): A ‚üπ C
}
#+end_src


*** Category as Monoid (preface)

#+begin_src scala :tangle CategoryParametric.scala
trait MonoidB
  [‚üπ[_[_, _], _[_, _]], I[_, _], ‚äó[_[_, _], _[_, _], _, _],
   A[_, _]] {
  def identity: I ‚üπ A
  def op: ‚äó[A, A, ?, ?] ‚üπ A
}

trait FunctionB[F[_, _], G[_, _]] {
  def apply[A, B](fab : F[A, B]): G[A, B]
}

final abstract class ComposeB[‚üπ[_, _], ‚üæ[_, _], A, B] {
  type Z
  def f: Z ‚üπ B
  def g: A ‚üæ Z
}
#+end_src

*** Category as Monoid

#+begin_src scala :tangle CategoryParametric.scala
trait Category π π[‚üπ[_, _]]
    extends MonoidB[FunctionB, cats.evidence.Is, ComposeB, ‚üπ] {
  def id[A]: A ‚üπ A
  def compose[A, B, C](f: B ‚üπ C, g: A ‚üπ B): A ‚üπ C

  def identity = new FunctionB[cats.evidence.Is, ‚üπ] {
    def apply[A, B](fab : cats.evidence.Is[A, B]) =
      fab.substitute[A ‚üπ ?](id)
  }
  // Œª[FunctionB[ComposeB[‚üπ, ‚üπ, ?, ?], ‚üπ]](compose(fab.f, fab.g))
  def op = new FunctionB[ComposeB[‚üπ, ‚üπ, ?, ?], ‚üπ] {
    def apply[A, B](fab : ComposeB[‚üπ, ‚üπ, A, B]) =
      compose(fab.f, fab.g)
  }
}
#+end_src

:speakernotes:
B = Bifunctor

But, what is a bifunctor? Different in category theory from Haskell / Scala. The B above is CT-ish, so, basically, any product category.
:END:

* Kind Polymorphism

:speakernotes:
Requires Dotty or Typelevel

Thanks to Pascal & Miles.
:END:

#+begin_src scala
trait CMonoid
    [‚üπ[_, _],
     I,
     ‚äó[_, _],
     A] {
  def identity: I ‚üπ A
  def op: (A ‚äó A) ‚üπ A
}
#+end_src

#+begin_src scala :tangle KindPoly.scala
package object KindPoly {
#+end_src













** ~AnyKind~

#+begin_src scala :tangle KindPoly.scala
trait Monoid
    [‚üπ[_ <: AnyKind, _ <: AnyKind],
     I <: AnyKind,
     ‚äó <: AnyKind, // ‚äó[_ <: AnyKind, _ <: AnyKind] <: AnyKind,
     A <: AnyKind] {
  def identity: I ‚üπ A
  def op: ‚äó ‚üπ A  // def op: (A ‚äó A) ‚üπ A
}
#+end_src

:speakernotes:
We‚Äôd like to use the commented-out forms, but it isn‚Äôt available with the syntax provided by Scala‚Äôs kind-polymorphism. This is a weakness, because remember earlier we said that ~‚äó~ is a /bifunctor/, but that isn‚Äôt enforced by this definition.

We can still define it with bifunctors, but we need to explicitly mention ~A~ twice in the ~‚äó~ argument.
:END:

#+begin_src scala :tangle KindPoly.scala
type ProperMonoid[A] = Monoid[Function1, Unit, (A, A), A]
#+end_src

:speakernotes:
That means we can inadvertantly specify /non/-monoids if we provide a bad ~‚äó~ argument.
:END:

#+begin_src scala :tangle KindPoly.scala
type FakeMonoid[A] = Monoid[Function1, Unit, List, A]
#+end_src

:speakernotes:
is in no way a valid monoid, but it‚Äôs not prevented by this definition. So, we /can/ define a kind-polymorphic ~Monoid~, but it means we have to be a /bit/ careful with the definitions.

There‚Äôs another problem, in that the operations constrain ~I~ and ~‚äó~ to the same kind, and ~‚üπ~ must match the kinds of ~I~ and ~A~ in its two parameters, but there is nothing saying that the two parameters of ~‚üπ~ must be of the same kind. But since ~‚üπ~ is meant to be a morphism in a category, and all objects in a category must be valid on either side of a morphism, the kinds are required to align ‚Äì but, again, it‚Äôs not enforced.

So, by generalizing ~Monoid~ in this way, we‚Äôve managed to unify many type classes
:END:

** mono ~Monoid~
:speakernotes:
But, at least in Scala, we‚Äôve lost some precision. If we are careful about that third parameter, then we should be ok, but there‚Äôs a risk.
:END:

#+begin_src scala
// Monoid
type ProperMonoid[A] = Monoid[Function1, Unit, (A, A), A]

// MonoidK
type MonoidK[F[_]] =
  Monoid[cats.arrow.FunctionK, cats.Id, cats.data.Tuple2K[F, F, ?],
         F]
type Applicative[F[_]] =
  Monoid[cats.arrow.FunctionK, cats.Id, Day[F, F, ?], F]
type Monad[M[_]] =
  Monoid[cats.arrow.FunctionK, cats.Id, cats.data.Nested[M, M, ?],
         M]

// MonoidB
type TypeCategory[‚üπ[_, _]] =
  Monoid[FunctionB, cats.evidence.Is, ComposeB[‚üπ, ‚üπ, ?, ?], ‚üπ]
#+end_src

** mono ~Functor~? üö´
:speakernotes:
In the case of a kind-polymorphic functor ‚Äì I can‚Äôt even figure out how to define it. In the first case, we can‚Äôt do the nested ~AnyKind~ on a type, and in the second case (using the same sort of trick from ~‚äó~), we have no way to apply the ~F~ to ~A~ or ~B~.

There may be some trick I‚Äôm unaware of to help with this.
:END:

#+begin_src scala
trait Functor
    [‚üπ[_ <: AnyKind, _ <: AnyKind],
     ‚üæ[_ <: AnyKind, _ <: AnyKind],
     F[_ <: AnyKind] <: AnyKind] {
  def map[A <: AnyKind, B <: AnyKind](f: A ‚üπ B): F[A] ‚üæ F[B]
}

trait Functor
    [‚üπ[_ <: AnyKind, _ <: AnyKind],
     ‚üæ[_ <: AnyKind, _ <: AnyKind],
     F <: AnyKind] {
  def map[A <: AnyKind, B <: AnyKind](f: A ‚üπ B): F ‚üæ F
}
#+end_src
















*** multiple type parameter lists

https://github.com/scala/bug/issues/4719

#+begin_src scala
F[_ <: AnyKind] <: AnyKind
#+end_src

#+begin_src scala
final case class Tuple2K[F[_], G[_], A](first: F[A], second: G[A])
#+end_src

#+begin_src scala
final case class Tuple2K[F[_], G[_]][A](first: F[A], second: G[A])
#+end_src

#+begin_src scala :tangle KindPoly.scala
}
#+end_src

* an exercise ‚Ä¶

#+begin_src scala :tangle KindPoly.scala
trait Category[‚üπ[_ <: AnyKind, _ <: AnyKind]] {
  def id[A <: AnyKind]: A ‚üπ A
  def compose[A <: AnyKind, B <: AnyKind, C <: AnyKind]
    (g: B ‚üπ C, f: A ‚üπ B)
      : A ‚üπ C
}
#+end_src

# * naturality vs. parametricity

#   :speakernotes:
# http://www.cs.bham.ac.uk/~udr/notes/naturality.pdf

# When dealing with category theory, there is a notion of ‚Äúnaturality‚Äù. You /may/ be familiar with the term ‚Äúnatural transformation‚Äù, and that is where the ‚Äúnatural‚Äù comes from.

# In Cats, there is
#   :END:

# #+begin_src scala :tangle CategoryParametric.scala
# sealed trait FunctionK[F[_], G[_]] {
#   def apply[A](fa: F[A]): G[A]
# }
# #+end_src

# :speakernotes:
# which encodes a natural transformation. It is like ~Function1~, but is a function between type /constructors/ rather than between types. The parametricity of ~A~ ensures that we can‚Äôt affect it in any way.

# But there was a subtle distinction between talking about a natural transformation in category theory and talking about ~FunctionK~ in Scala ‚Äì when talking about the former, I said ‚Äúnaturality‚Äù, but when talking about the latter, I said ‚Äúparametricity‚Äù. Are they just the same thing in different lexicons?

# Unfortunately not. It turns out parametricity is a stronger claim than naturality. So, there are natural transformations that can‚Äôt be expressed via Cats‚Äô ~FunctionK~. But again, with a bit of hand-waving, it works.
# :END:


* Questions?

#+begin_src scala :tangle CategoryParametric.scala
}
#+end_src

Greg Pfeil

Formation.ai ‚Äì ML for customer relationships

Thanks to
- Erik Osheim (@d6) for ~kind-projector~,
- Pascal Voitot (@mandubian) for ~-Ykind-polymorphism~ 
# and the fun I‚Äôve gotten to have when using it,
- Miles Sabin (@milessabin) for Typelevel Scala
# and all his efforts around making FP more feasible in Scala,
- Rob Norris (@tpolecat)
 # for putting a bucket over his head every time I went off the rails on something ‚Äì any remaining Crazy Train in this talk is due to me ignoring him (so be glad I listened as much as I did),
- Typelevel.org in general
# for their work in providing a solid base of FP tooling, 
- Scala.io
# for having me here to either entice or annoy you with these ideas, and
- so many others inside and outside the Scala community
# for helping me understand the things I do ‚Äì I only hope I can pay it forward
